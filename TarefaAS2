1.1 Transforme a gramática X++ que está em LL(3) para uma gramática que está em LL(1) (chame tal gramática de LL1X++):

Sabemos que uma gramática está em LL(1) se estiver fatorada à esquerda. Conforme haviamos visto na questão 2 da TarefaAS1, a gramática fatorada fica idêntica à original, exceto pelas produções de statement, que devem ser substituidas pelas novas:

statement → (INT | STRING) IDENT (ABRCOL FECHCOL)* (VIRG IDENT ( ABRCOL FECHCOL)*)* PTVIR | IDENT statement1 |
            readstat PTVIR | returnstat PTVIR | ifstat | forstat PTVIR | ABRCHAVE statlist FECHCHAVE | BREAK PTVIR | PTVIR;

Também devemos adicionar as novas produções de statement1:

statement1 → IDENT (ABRCOL FECHCOL)* (VIRG IDENT ( ABRCOL FECHCOL)*)* PTVIR |
               (ABRCOL expression FECHCOL | PONTO IDENT ( ABRPAR arglist FECHPAR )?)* ATR (expression | alocexpression) PTVIR;

Após realizar estas modificações, a gramática foi adaptada para seguir a notação convencional, conforme requerido no enunciado. Para isto, foram criados mais alguns símbolos não terminais.

Obs: os fragmentos não são considerados produções da gramática.


1.2. Prove de que LL1X++ está em LL(1):

Sejam:
> A ∈ Vn
> α, β ∈ V*
> ⇒* indica uma derivação em zero ou mais passos.

Podemos provar por meio do teorema visto em sala de aula: a gramática é LL(1) se as seguintes condições forem satisfeitas:

Para qualquer A → α|β :
1.2.1: first(α) ∩ first(β) = φ
1.2.2: α → ε ou β → ε, mas não ambos
1.2.3 se α ⇒* ε ou β ⇒* ε, então first(A) ∩ follow(A) = φ

Computamos os conjuntos first para todas as produções de todos os Vn da gramática:
Para maior clareza, seja abaixo first(A) = first(α) ∪ first(β), mas se houverem itens repetidos, eles aparecerão repetidos no conjunto first(A).

first(classbody) = {ABRCHAVE}
first(intstringident) = {INT, STRING, IDENT} 
first(vardecl) = {INT, STRING, IDENT} 
first(cols) = {ABRCOL, ε}
first(vardecl1) = {VIRG, ε}
first(constructdecl) = {CONSTRUCTOR}
first(methoddecl) = {INT, STRING, IDENT} 
first(methodbody) = {ABRPAR}
first(paramlist) =  {INT, STRING, IDENT, ε}
first(paramlist1) = {VIRG, ε}
first(intstring) = {INT, STRING}
first(virgidentcols) = {VIRG, ε}
first(statement2) = {ABRCOL, PONTO, ε}
first(statement1) = {IDENT, ABRCOL, PONTO, ATR}
first(statement3) = {IDENT}
first(printstat) = {PRINT}
first(readstat) = {READ}
first(returnstat) = {RETURN}
first(superstat) = {SUPER}
first(ifstat) = {IF}
first(ifstat1) = {ELSE, ε}
first(forstat) = {FOR}
first(lvalue) = {IDENT}
first(lvalue2) = {ABRCOL, PONTO, ε}
first(lvalue3) = {ABRPAR, ε}
first(alocexpression) = {NEW}
first(alocexpression2) = {ABRCOL}
first(alocexpression3) = {IDENT, INT, STRING}
first(alocexpression4) = {ABRCOL, ε}
first(alocexpression5) = {ABRPAR, ABRCOL}
first(expression2) = {MENOR, MAIOR, MENORIG, MAIORIG, IGUAL, DIFER}
first(expresion3) = {MENOR, MAIOR, MENORIG, MAIORIG, IGUAL, DIFER, ε}
first(numexpression1) = {OPMAIS, OPMENOS, ε}
first(term1) = {OPVEZES, OPDIV, OPMOD, ε}
first(factor) = {INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR}
first(arglist1) = {VIRG, ε}
first(classdecl) = {CLASS}
first(classbody1) = {INT, STRING, IDENT, ε}
first(classbody2) = {CONSTRUCTOR, ε}
first(classbody3) = {INT, STRING, IDENT, ε}
first(statement) = {INT, STRING, IDENT, PRINT, READ, RETURN, IF, FOR, ABRCHAVE, BREAK, PTVIR}
first(statement4) = {ABRPAR, ABRCOL, PONTO, ε}
first(atribstat) = {IDENT}
first(forstat1) = {IDENT, ε}
first(statlist) = {INT, STRING, IDENT, PRINT, READ, RETURN, IF, FOR, ABRCHAVE, BREAK, PTVIR}
first(statlist1) = {INT, STRING, IDENT, PRINT, READ, RETURN, IF, FOR, ABRCHAVE, BREAK, PTVIR, ε}
first(unaryexpr) = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR}
first(classlist) = {CLASS}
first(classlist2) = {CLASS, ε}
first(classdecl2) = {ABRCHAVE, EXTENDS}
first(term) = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR}
first(program) = {CLASS, ε}
first(numexpression) = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR}
first(expression) = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR}
first(arglist) = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR, ε}
first(expralocexpr) = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR, NEW}
first(returnstat1) = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR, ε}
first(expression) = {PTVIR, OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR}


Agora, verificamos as condições 1.2.1, 1.2.2 e 1.2.3 para todas as produções da gramática:

1.2.1: first(α) ∩ first(β) = φ
Como podemos ver nos conjuntos first computados acima, não existem itens repetidos em nenhum first(A), portanto, esta condição é cumprida.

1.2.2: α → ε ou β → ε, mas não ambos
Esta condição também é cumprida pelo mesmo motivo da condição 1.2.1: Cada conjunto first(A) somente contem epsilon uma vez.

1.2.3 se α ⇒* ε ou β ⇒* ε, então first(A) ∩ follow(A) = φ

Computamos os conjuntos follow para os terminais onde ε ∈ first(A), isto é, A ⇒* ε:







1) FOLLOW(S) = { $ }   // where S is the starting Non-Terminal

2) If A -> pBq is a production, where p, B and q are any grammar symbols,
   then everything in FIRST(q)  except ? is in FOLLOW(B.

3) If A->pB is a production, then everything in FOLLOW(A) is in FOLLOW(B).

4) If A->pBq is a production and FIRST(q) contains ?, 
   then FOLLOW(B) contains { FIRST(q) – ? } U FOLLOW(A) 









follow(cols) 	= first(vardecl1) ∪ first(IDENT) ∪ first(paramlist1) ∪ first(virgidentcols)
			 	=  {VIRG} ∪ follow(vardecl) ∪ follow(vardecl1) ∪ {IDENT} ∪ {VIRG} ∪ follow(paramlist) ∪ follow(paramlist1) ∪ {VIRG} ∪ {PTVIR} ∪ follow(virgidentcols)









follow(vardecl1) = 
follow(paramlist) =  
follow(paramlist1) = 
follow(virgidentcols) = 
follow(statement2) = 
follow(ifstat1) = 
follow(lvalue2) = 
follow(lvalue3) = 
follow(alocexpression4) = 
follow(expresion3) = 
follow(numexpression1) = 
follow(term1) = 
follow(arglist1) = 
follow(classbody1) = 
follow(classbody2) = 
follow(classbody3) = 
follow(statement4) = 
follow(forstat1) = 
follow(statlist1) = 
follow(classlist2) = 
follow(program) = 
follow(arglist) = 
follow(returnstat1) = 





















first(A, B) : A->B



follow(program) = {EOF}
follow(classlist) = follow(program), follow(classlist2), first(classbody1 classbody2 classbody3 FECHCHAVE)
follow(classdecl) = first(classlist2, epsilon=follow(classlist)),
follow(classlist2) = follow(classlist)
follow(classdecl2) = follow(classdecl) 
follow(classbody) = {EXTENDS}, follow(classbody)
follow(classbody1) = first(classbody2 classbody3 FECHCHAVE)
follow(classbody2) = first(classbody3 FECHCHAVE)
folllow(classbody3) = {FECHCHAVE}
follow(vardecl) = {PTVIR}
follow(constructdecl) = first(classbody2; epsilon=follow(classbody2)
follow(methoddecl) = first(classbody3, epsilon=follow(classbody3))
follow(intstringident) = {IDENT}, first(cols IDENT methodbody)
follow(cols) = first(vardecl1, epsilon=follow(vardecl)), first(vardecl1, epsilon=follow(vardecl1)), {IDENT}, first(paramlist1, epsilon=follow(paramlist)), first(paramlist1, epsilon=follow(paramlist1)), first(virgidentcols PTVIR), first(virgidentcols, epsilon=follow(virgidentcols))

follow(vardecl1) = follow(vardecl1)
follow(methodbody) = follow(constructdecl), follow(methoddecl)
follow(paramlist) = {FECHPAR}
follow(statement) = follow(methodbody), first(ifstat1, epsilon=follow(ifstat)), follow(ifstat1), follow(forstat2), first(statlist1, epsilon=follow(statlist))
follow(paramlist1) = follow(paramlist)
follow(virgidentcols) = {PTVIR}
follow(statement2) = follow(statement)
follow(printstat) = {PTVIR}
follow(readstat) = {PTVIR}
follow(returnstat) = {PTVIR}
follow(ifstat) = follow(statement)
follow(forstat) = follow(statement)
follow(statlist) = {FECHCHAVE}, follow(statlist1)
follow(statement3) = {ATR}
follow(expralocexpr) = {PTVIR}, follow(atribstat)
follow(expression) = {FECHCOL, FECHPAR, PTVIR}, follow(expralocexpr), follow(printstat), follow(returnstat1), first(arglist1, epsilon=follow(arglist), first(arglist1, epsilon=follow(arglist1)
follow(arglist) = {FECHCOL, FECHPAR}
follow(alocexpression) = follow(expralocexpr)
follow(lvalue) = {ATR}, follow(readstat), follow(factor)
follow(returnstat1) = follow(returnstat)
follow(ifstat1) = follow(ifstat)
follow(forstat1) = {PTVIR, FECHPAR}
follow(forstat2) = follow(forstat)
follow(atribstat) = follow(atribstat1)
follow(statlist1) = follow(statlist)
follow(lvalue2) = follow(lvalue), follow(lvalue3)
follow(lvalue3) = follow(lvalue2)
follow(alocexpression3) = follow(alocexpression)
follow(alocexpression4) = follow(alocexpression2)
follow(alocexpression5) = follow(alocexpression3)
follow(alocexpression2) = follow(alocexpression3), follow(alocexpression4), follow(alocexpression5)
follow(numexpression) = first(expresion3, epsilon=follow(expresion)), follow(expression3)
follow(expresion3) = follow(expresion)
follow(expression2) = first(numexpression, epsilon=follow(expression3))
follow(term) = first(numexpression2, epsilon=follow(numexpression)), first(numexpression2, epsilon=follow(numexpression2))
follow(numexpression2) = follow(numexpression)
follow(unaryexpr) = first(term1, epsilon=follow(term)), first(term1, epsilon=follow(term1))
follow(term1) = follow(term)
follow(factor) = follow(unaryexpr)
follow(arglist1) = follow(arglist)




















Sendo EOF o símbolo que indica o final do programa.

Agora, verificamos as condições 1.2.1, 1.2.2 e 1.2.3 para todas as produções da gramática:

1.2.1: first(α) ∩ first(β) = φ:



pode testar com a tabela, desde que seja livre rec À esquerda e fatorada à esquerda


 
1.3. construa um analisador sintático para LL1X++:
