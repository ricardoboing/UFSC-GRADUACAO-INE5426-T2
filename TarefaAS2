1.1 Transforme a gramática X++ que está em LL(3) para uma gramática que está em LL(1) (chame tal gramática de LL1X++):

Sabemos que uma gramática está em LL(1) se estiver fatorada à esquerda. Conforme haviamos visto na questão 2 da TarefaAS1, a gramática fatorada fica idêntica à original, exceto pelas produções de statement, que devem ser substituidas pelas novas:

statement → (INT | STRING) IDENT (ABRCOL FECHCOL)* (VIRG IDENT ( ABRCOL FECHCOL)*)* PTVIR | IDENT statement1 |
            readstat PTVIR | returnstat PTVIR | ifstat | forstat PTVIR | ABRCHAVE statlist FECHCHAVE | BREAK PTVIR | PTVIR;

Também devemos adicionar as novas produções de statement1:

statement1 → IDENT (ABRCOL FECHCOL)* (VIRG IDENT ( ABRCOL FECHCOL)*)* PTVIR |
               (ABRCOL expression FECHCOL | PONTO IDENT ( ABRPAR arglist FECHPAR )?)* ATR (expression | alocexpression) PTVIR;

Após realizar estas modificações, a gramática foi adaptada para seguir a notação convencional, conforme requerido no enunciado. Para isto, foram criados mais alguns símbolos não terminais.

Obs: os fragmentos não são considerados produções da gramática.


1.2. Prove de que LL1X++ está em LL(1):

Sejam:
> A ∈ Vn
> α, β ∈ V*
> ⇒* indica uma derivação em zero ou mais passos.

Podemos provar por meio do teorema visto em sala de aula: a gramática é LL(1) se as seguintes condições forem satisfeitas:

Para qualquer A → α|β :
1.2.1: first(α) ∩ first(β) = φ
1.2.2: α → ε ou β → ε, mas não ambos
1.2.3 se α ⇒* ε ou β ⇒* ε, então first(A) ∩ follow(A) = φ

Computamos os conjuntos first e follow para todas as produções de todos os Vn da gramática:

first(classbody) = {ABRCHAVE}
first(intstringident) = {INT, STRING, IDENT} 
first(vardecl) = {INT, STRING, IDENT} 
first(cols) = {ABRCOL, ε}
first(vardecl1) = {VIRG, ε}
first(constructdecl) = {CONSTRUCTOR}
first(methoddecl) = {INT, STRING, IDENT} 
first(methodbody) = {ABRPAR}
first(paramlist) =  {INT, STRING, IDENT, ε}
first(paramlist1) = {VIRG, ε}
first(intstring) = {INT, STRING}
first(virgidentcols) = {VIRG, ε}
first(statement2) = {ABRCOL, PONTO, ε}
first(statement1) = {IDENT, ABRCOL, PONTO, ATR}
first(statement3) = {IDENT}
first(printstat) = {PRINT}
first(readstat) = {READ}
first(returnstat) = {RETURN}
first(superstat) = {SUPER}
first(ifstat) = {IF}
first(ifstat1) = {ELSE, ε}
first(forstat) = {FOR}
first(lvalue) = {IDENT}
first(lvalue2) = {ABRCOL, PONTO, ε}
first(lvalue3) = {ABRPAR, ε}
first(alocexpression) = {NEW}
first(alocexpression2) = {ABRCOL}
first(alocexpression3) = {IDENT, INT, STRING}
first(alocexpression4) = {ABRCOL, ε}
first(alocexpression5) = {ABRPAR, ABRCOL}
first(expression2) = {MENOR, MAIOR, MENORIG, MAIORIG, IGUAL, DIFER}
first(expresion3) = {MENOR, MAIOR, MENORIG, MAIORIG, IGUAL, DIFER, ε}
first(numexpression1) = {OPMAIS, OPMENOS, ε}
first(term1) = {OPVEZES, OPDIV, OPMOD, ε}
first(factor) = {INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR}
first(arglist1) = {VIRG, ε}
first(classdecl) = {CLASS}
first(classbody1) = {INT, STRING, IDENT, ε}
first(classbody2) = {CONSTRUCTOR, ε}
first(classbody3) = {INT, STRING, IDENT, ε}
first(statement) = {INT, STRING, IDENT, PRINT, READ, RETURN, IF, FOR, ABRCHAVE, BREAK, PTVIR}
first(statement4) = {ABRPAR, ABRCOL, PONTO, ε}
first(atribstat) = {IDENT}
first(forstat1) = {IDENT, ε}
first(statlist) = {INT, STRING, IDENT, PRINT, READ, RETURN, IF, FOR, ABRCHAVE, BREAK, PTVIR}
first(statlist1) = {INT, STRING, IDENT, PRINT, READ, RETURN, IF, FOR, ABRCHAVE, BREAK, PTVIR, ε}
first(unaryexpr) = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR}
first(classlist) = {CLASS}
first(classlist2) = {CLASS, ε}
first(classdecl2) = {ABRCHAVE, EXTENDS}
first(term) = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR}
first(program) = {CLASS, ε}
first(numexpression) = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR}
first(expression) = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR}
first(arglist) = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR, ε}
first(expralocexpr) = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR, NEW}
first(returnstat1) = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR, ε}
first(expression) = {PTVIR, OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR}















Agora, verificamos as condições 1.2.1, 1.2.2 e 1.2.3 para todas as produções da gramática:

1.2.1: first(α) ∩ first(β) = φ:



pode testar com a tabela, desde que seja livre rec À esquerda e fatorada à esquerda


 
1.3. construa um analisador sintático para LL1X++:
