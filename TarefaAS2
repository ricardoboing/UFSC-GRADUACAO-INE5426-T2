1.1 Transforme a gramática X++ que está em LL(3) para uma gramática que está em LL(1) (chame tal gramática de LL1X++):

Sabemos que uma gramática está em LL(1) se estiver fatorada à esquerda. Conforme haviamos visto na questão 2 da TarefaAS1, a gramática fatorada fica idêntica à original, exceto pelas produções de statement, que devem ser substituidas pelas novas:

statement → (INT | STRING) IDENT (ABRCOL FECHCOL)* (VIRG IDENT ( ABRCOL FECHCOL)*)* PTVIR | IDENT statement1 |
            readstat PTVIR | returnstat PTVIR | ifstat | forstat PTVIR | ABRCHAVE statlist FECHCHAVE | BREAK PTVIR | PTVIR;

Também devemos adicionar as novas produções de statement1:

statement1 → IDENT (ABRCOL FECHCOL)* (VIRG IDENT ( ABRCOL FECHCOL)*)* PTVIR |
               (ABRCOL expression FECHCOL | PONTO IDENT ( ABRPAR arglist FECHPAR )?)* ATR (expression | alocexpression) PTVIR;

Após realizar estas modificações, a gramática foi adaptada para seguir a notação convencional, conforme requerido no enunciado. Para isto, foram criados mais alguns símbolos não terminais.

Obs: os fragmentos não são considerados produções da gramática.


1.2. Prove de que LL1X++ está em LL(1):

Sejam:
> A ∈ Vn
> α, β ∈ V*
> ⇒* indica uma derivação em zero ou mais passos.

Podemos provar por meio do teorema visto em sala de aula: a gramática é LL(1) se as seguintes condições forem satisfeitas:

Para qualquer A → α|β :
1.2.1: first(α) ∩ first(β) = φ
1.2.2: α → ε ou β → ε, mas não ambos
1.2.3 se α ⇒* ε ou β ⇒* ε, então first(A) ∩ follow(A) = φ

Computamos os conjuntos first para todas as produções de todos os Vn da gramática:
Para maior clareza, seja abaixo first(A) = first(α) ∪ first(β), mas se houverem itens repetidos, eles aparecerão repetidos no conjunto first(A).

first(classbody) = {ABRCHAVE}
first(intstringident) = {INT, STRING, IDENT} 
first(vardecl) = {INT, STRING, IDENT} 
first(cols) = {ABRCOL, ε}
first(vardecl1) = {VIRG, ε}
first(constructdecl) = {CONSTRUCTOR}
first(methoddecl) = {INT, STRING, IDENT} 
first(methodbody) = {ABRPAR}
first(paramlist) =  {INT, STRING, IDENT, ε}
first(paramlist1) = {VIRG, ε}
first(intstring) = {INT, STRING}
first(virgidentcols) = {VIRG, ε}
first(statement2) = {ABRCOL, PONTO, ε}
first(statement1) = {IDENT, ABRCOL, PONTO, ATR}
first(statement3) = {IDENT}
first(printstat) = {PRINT}
first(readstat) = {READ}
first(returnstat) = {RETURN}
first(superstat) = {SUPER}
first(ifstat) = {IF}
first(ifstat1) = {ELSE, ε}
first(forstat) = {FOR}
first(lvalue) = {IDENT}
first(lvalue2) = {ABRCOL, PONTO, ε}
first(lvalue3) = {ABRPAR, ε}
first(alocexpression) = {NEW}
first(alocexpression2) = {ABRCOL}
first(alocexpression3) = {IDENT, INT, STRING}
first(alocexpression4) = {ABRCOL, ε}
first(alocexpression5) = {ABRPAR, ABRCOL}
first(expression2) = {MENOR, MAIOR, MENORIG, MAIORIG, IGUAL, DIFER}
first(expresion3) = {MENOR, MAIOR, MENORIG, MAIORIG, IGUAL, DIFER, ε}
first(numexpression2) = {OPMAIS, OPMENOS, ε}
first(term1) = {OPVEZES, OPDIV, OPMOD, ε}
first(factor) = {INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR}
first(arglist1) = {VIRG, ε}
first(classdecl) = {CLASS}
first(classbody1) = {INT, STRING, IDENT, ε}
first(classbody2) = {CONSTRUCTOR, ε}
first(classbody3) = {INT, STRING, IDENT, ε}
first(statement) = {INT, STRING, IDENT, PRINT, READ, RETURN, IF, FOR, ABRCHAVE, BREAK, PTVIR}
first(statement4) = {ABRPAR, ABRCOL, PONTO, ε}
first(atribstat) = {IDENT}
first(forstat1) = {IDENT, ε}
first(statlist) = {INT, STRING, IDENT, PRINT, READ, RETURN, IF, FOR, ABRCHAVE, BREAK, PTVIR}
first(statlist1) = {INT, STRING, IDENT, PRINT, READ, RETURN, IF, FOR, ABRCHAVE, BREAK, PTVIR, ε}
first(unaryexpr) = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR}
first(classlist) = {CLASS}
first(classlist2) = {CLASS, ε}
first(classdecl2) = {ABRCHAVE, EXTENDS}
first(term) = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR}
first(program) = {CLASS, ε}
first(numexpression) = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR}
first(expression) = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR}
first(arglist) = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR, ε}
first(expralocexpr) = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR, NEW}
first(returnstat1) = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR, ε}
first(expression) = {PTVIR, OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR}


Agora, verificamos as condições 1.2.1, 1.2.2 e 1.2.3 para todas as produções da gramática:

1.2.1: first(α) ∩ first(β) = φ
Como podemos ver nos conjuntos first computados acima, não existem itens repetidos em nenhum first(A), portanto, esta condição é cumprida.

1.2.2: α → ε ou β → ε, mas não ambos
Esta condição também é cumprida pelo mesmo motivo da condição 1.2.1: Cada conjunto first(A) somente contem epsilon uma vez.

1.2.3 se α ⇒* ε ou β ⇒* ε, então first(A) ∩ follow(A) = φ

Computamos os conjuntos follow para os terminais onde ε ∈ first(A), isto é, A ⇒* ε:







1) FOLLOW(S) = { $ }   // where S is the starting Non-Terminal

2) If A -> pBq is a production, where p, B and q are any grammar symbols,
   then everything in FIRST(q)  except ? is in FOLLOW(B.

3) If A->pB is a production, then everything in FOLLOW(A) is in FOLLOW(B).

4) If A->pBq is a production and FIRST(q) contains ?, 
   then FOLLOW(B) contains { FIRST(q) – ? } U FOLLOW(A) 









follow(cols) 	= first(vardecl1) ∪ first(IDENT) ∪ first(paramlist1) ∪ first(virgidentcols)
			 	=  {VIRG} ∪ follow(vardecl) ∪ follow(vardecl1) ∪ {IDENT} ∪ {VIRG} ∪ follow(paramlist) ∪ follow(paramlist1) ∪ {VIRG} ∪ {PTVIR} ∪ follow(virgidentcols)









follow(vardecl1) = 
follow(paramlist) =  
follow(paramlist1) = 
follow(virgidentcols) = 
follow(statement2) = 
follow(ifstat1) = 
follow(lvalue2) = 
follow(lvalue3) = 
follow(alocexpression4) = 
follow(expresion3) = 
follow(numexpression2) = 
follow(term1) = 
follow(arglist1) = 
follow(classbody1) = 
follow(classbody2) = 
follow(classbody3) = 
follow(statement4) = 
follow(forstat1) = 
follow(statlist1) = 
follow(classlist2) = 
follow(program) = 
follow(arglist) = 
follow(returnstat1) = 





















first(A, B) : A->B



follow(program) = {EOF}
follow(classlist) = {EOF, INT, STRING, IDENT, CONSTRUCTOR, FECHCHAVE}
follow(classdecl) = {CLASS, EOF, INT, STRING, IDENT, CONSTRUCTOR, FECHCHAVE}
follow(classlist2) = {EOF, INT, STRING, IDENT, CONSTRUCTOR, FECHCHAVE}
follow(classdecl2) = {CLASS, EOF, INT, STRING, IDENT, CONSTRUCTOR, FECHCHAVE}
follow(classbody) = {EXTENDS}
follow(classbody1) = {CONSTRUCTOR, INT, STRING, IDENT, FECHCHAVE}
follow(classbody2) = {INT, STRING, IDENT, FECHCHAVE}
folllow(classbody3) = {FECHCHAVE}
follow(vardecl) = {PTVIR}
follow(constructdecl) = {CONSTRUCTOR, INT, STRING, IDENT, FECHCHAVE}
follow(methoddecl) = {INT, STRING, IDENT, FECHCHAVE}
follow(intstringident) = {IDENT, ABRCOL} 
follow(vardecl1) = {PTVIR}
follow(methodbody) = {CONSTRUCTOR, INT, STRING, IDENT, FECHCHAVE}
follow(paramlist) = {FECHPAR}
follow(paramlist1) = {FECHPAR}
follow(virgidentcols) = {PTVIR}
follow(printstat) = {PTVIR}
follow(readstat) = {PTVIR}
follow(returnstat) = {PTVIR}
follow(statement3) = {ATR}
follow(arglist) = {FECHCOL, FECHPAR}
follow(returnstat1) = {PTVIR}
follow(forstat1) = {PTVIR, FECHPAR}
follow(atribstat) = {PTVIR, FECHPAR}
follow(expralocexpr) = {PTVIR, FECHPAR}
follow(alocexpression) = {PTVIR, FECHPAR}
follow(statlist1) = {FECHCHAVE}
follow(statlist) = {FECHCHAVE}
follow(alocexpression3) = {PTVIR, FECHPAR}
follow(alocexpression5) = {PTVIR, FECHPAR}
follow(alocexpression2) = {PTVIR, FECHPAR}
follow(alocexpression4) = {PTVIR, FECHPAR}
follow(expression2) = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR}
follow(arglist1) = {FECHCOL, FECHPAR}
follow(cols) = {VIRG, IDENT, PTVIR, FECHPAR}
follow(expression) = {FECHCOL, FECHPAR, PTVIR, VIRG}
follow(forstat) =  {CONSTRUCTOR, INT, STRING, IDENT, FECHCHAVE, ELSE, PRINT, READ, RETURN, IF, FOR, ABRCHAVE, BREAK, PTVIR}
follow(forstat2) =  {CONSTRUCTOR, INT, STRING, IDENT, FECHCHAVE, ELSE, PRINT, READ, RETURN, IF, FOR, ABRCHAVE, BREAK, PTVIR}
follow(ifstat1) = {CONSTRUCTOR, INT, STRING, IDENT, FECHCHAVE, ELSE, PRINT, READ, RETURN, IF, FOR, ABRCHAVE, BREAK, PTVIR}
follow(statement) =  {CONSTRUCTOR, INT, STRING, IDENT, FECHCHAVE, ELSE, PRINT, READ, RETURN, IF, FOR, ABRCHAVE, BREAK, PTVIR}
follow(statement2) = {CONSTRUCTOR, INT, STRING, IDENT, FECHCHAVE, ELSE, PRINT, READ, RETURN, IF, FOR, ABRCHAVE, BREAK, PTVIR}
follow(forstat) = {CONSTRUCTOR, INT, STRING, IDENT, FECHCHAVE, ELSE, PRINT, READ, RETURN, IF, FOR, ABRCHAVE, BREAK, PTVIR}
follow(ifstat) = {CONSTRUCTOR, INT, STRING, IDENT, FECHCHAVE, ELSE, PRINT, READ, RETURN, IF, FOR, ABRCHAVE, BREAK, PTVIR}
follow(lvalue) = {ATR, PTVIR, OPVEZES, OPDIV, OPMOD, OPMAIS, OPMENOS, MENOR, MAIOR, MENORIG, MAIORIG, IGUAL, DIFER, FECHCOL, FECHPAR, VIRG} 
follow(lvalue2) = {ATR, PTVIR, OPVEZES, OPDIV, OPMOD, OPMAIS, OPMENOS, MENOR, MAIOR, MENORIG, MAIORIG, IGUAL, DIFER, FECHCOL, FECHPAR, VIRG} 
follow(lvalue3) = {ATR, PTVIR, OPVEZES, OPDIV, OPMOD, OPMAIS, OPMENOS, MENOR, MAIOR, MENORIG, MAIORIG, IGUAL, DIFER, FECHCOL, FECHPAR, VIRG} 
follow(numexpression) = {MENOR, MAIOR, MENORIG, MAIORIG, IGUAL, DIFER, FECHCOL, FECHPAR, PTVIR, VIRG}
follow(numexpression2) = {MENOR, MAIOR, MENORIG, MAIORIG, IGUAL, DIFER, FECHCOL, FECHPAR, PTVIR, VIRG}
follow(expression3) = {FECHCOL, FECHPAR, PTVIR, VIRG, MENOR, MAIOR, MENORIG, MAIORIG, IGUAL, DIFER}
follow(term) = {OPMAIS, OPMENOS, MENOR, MAIOR, MENORIG, MAIORIG, IGUAL, DIFER, FECHCOL, FECHPAR, PTVIR, VIRG}
follow(term1) = {OPMAIS, OPMENOS, MENOR, MAIOR, MENORIG, MAIORIG, IGUAL, DIFER, FECHCOL, FECHPAR, PTVIR, VIRG}
follow(unaryexpr) = {OPVEZES, OPDIV, OPMOD, OPMAIS, OPMENOS, MENOR, MAIOR, MENORIG, MAIORIG, IGUAL, DIFER, FECHCOL, FECHPAR, PTVIR, VIRG}
follow(factor) = {OPVEZES, OPDIV, OPMOD, OPMAIS, OPMENOS, MENOR, MAIOR, MENORIG, MAIORIG, IGUAL, DIFER, FECHCOL, FECHPAR, PTVIR, VIRG}










Sendo EOF o símbolo que indica o final do programa.

Agora, verificamos as condições 1.2.1, 1.2.2 e 1.2.3 para todas as produções da gramática:

1.2.1: first(α) ∩ first(β) = φ:



pode testar com a tabela, desde que seja livre rec À esquerda e fatorada à esquerda


 
1.3. construa um analisador sintático para LL1X++:
