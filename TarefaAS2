1.1 Transforme a gramática X++ que está em LL(3) para uma gramática que está em LL(1) (chame tal gramática de LL1X++):

Sabemos que uma gramática está em LL(1) se estiver fatorada à esquerda. Conforme haviamos visto na questão 2 da TarefaAS1, a gramática fatorada fica idêntica à original, exceto pelas produções de statement, que devem ser substituidas pelas novas:

statement → (INT | STRING) IDENT (ABRCOL FECHCOL)* (VIRG IDENT ( ABRCOL FECHCOL)*)* PTVIR | IDENT statement1 |
            readstat PTVIR | returnstat PTVIR | ifstat | forstat PTVIR | ABRCHAVE statlist FECHCHAVE | BREAK PTVIR | PTVIR;

Também devemos adicionar as novas produções de statement1:

statement1 → IDENT (ABRCOL FECHCOL)* (VIRG IDENT ( ABRCOL FECHCOL)*)* PTVIR |
               (ABRCOL expression FECHCOL | PONTO IDENT ( ABRPAR arglist FECHPAR )?)* ATR (expression | alocexpression) PTVIR;

Após realizar estas modificações, a gramática foi adaptada para seguir a notação convencional, conforme requerido no enunciado. Para isto, foram criados mais alguns símbolos não terminais.

Obs: os fragmentos não são considerados produções da gramática.


1.2. Prove de que LL1X++ está em LL(1):

Sejam:
> A ∈ Vn
> α, β ∈ V*
> ⇒* indica uma derivação em zero ou mais passos.

Podemos provar por meio do teorema visto em sala de aula: a gramática é LL(1) se as seguintes condições forem satisfeitas:

Para qualquer A → α|β :
1.2.1: first(α) ∩ first(β) = φ
1.2.2: α → ε ou β → ε, mas não ambos
1.2.3 se α ⇒* ε ou β ⇒* ε, então first(A) ∩ follow(A) = φ

Computamos os conjuntos first para todas as produções de todos os Vn da gramática:
Para maior clareza, seja abaixo first(A) = first(α) ∪ first(β), mas se houverem itens repetidos, eles aparecerão repetidos no conjunto first(A).

first(classbody) = {ABRCHAVE}
first(intstringident) = {INT, STRING, IDENT} 
first(vardecl) = {INT, STRING, IDENT} 
first(cols) = {ABRCOL, ε}
first(vardecl1) = {VIRG, ε}
first(constructdecl) = {CONSTRUCTOR}
first(methoddecl) = {INT, STRING, IDENT} 
first(methodbody) = {ABRPAR}
first(paramlist) =  {INT, STRING, IDENT, ε}
first(paramlist1) = {VIRG, ε}
first(intstring) = {INT, STRING}
first(virgidentcols) = {VIRG, ε}
first(statement2) = {ABRCOL, PONTO, ε}
first(statement1) = {IDENT, ABRCOL, PONTO, ATR}
first(statement3) = {IDENT}
first(printstat) = {PRINT}
first(readstat) = {READ}
first(returnstat) = {RETURN}
first(superstat) = {SUPER}
first(ifstat) = {IF}
first(ifstat1) = {ELSE, ε}
first(forstat) = {FOR}
first(lvalue) = {IDENT}
first(lvalue2) = {ABRCOL, PONTO, ε}
first(lvalue3) = {ABRPAR, ε}
first(alocexpression) = {NEW}
first(alocexpression2) = {ABRCOL}
first(alocexpression3) = {IDENT, INT, STRING}
first(alocexpression4) = {ABRCOL, ε}
first(alocexpression5) = {ABRPAR, ABRCOL}
first(expression2) = {MENOR, MAIOR, MENORIG, MAIORIG, IGUAL, DIFER}
first(expresion3) = {MENOR, MAIOR, MENORIG, MAIORIG, IGUAL, DIFER, ε}
first(numexpression1) = {OPMAIS, OPMENOS, ε}
first(term1) = {OPVEZES, OPDIV, OPMOD, ε}
first(factor) = {INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR}
first(arglist1) = {VIRG, ε}
first(classdecl) = {CLASS}
first(classbody1) = {INT, STRING, IDENT, ε}
first(classbody2) = {CONSTRUCTOR, ε}
first(classbody3) = {INT, STRING, IDENT, ε}
first(statement) = {INT, STRING, IDENT, PRINT, READ, RETURN, IF, FOR, ABRCHAVE, BREAK, PTVIR}
first(statement4) = {ABRPAR, ABRCOL, PONTO, ε}
first(atribstat) = {IDENT}
first(forstat1) = {IDENT, ε}
first(statlist) = {INT, STRING, IDENT, PRINT, READ, RETURN, IF, FOR, ABRCHAVE, BREAK, PTVIR}
first(statlist1) = {INT, STRING, IDENT, PRINT, READ, RETURN, IF, FOR, ABRCHAVE, BREAK, PTVIR, ε}
first(unaryexpr) = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR}
first(classlist) = {CLASS}
first(classlist2) = {CLASS, ε}
first(classdecl2) = {ABRCHAVE, EXTENDS}
first(term) = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR}
first(program) = {CLASS, ε}
first(numexpression) = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR}
first(expression) = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR}
first(arglist) = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR, ε}
first(expralocexpr) = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR, NEW}
first(returnstat1) = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR, ε}
first(expression) = {PTVIR, OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR}


Agora, verificamos as condições 1.2.1, 1.2.2 e 1.2.3 para todas as produções da gramática:

1.2.1: first(α) ∩ first(β) = φ
Como podemos ver nos conjuntos first computados acima, não existem itens repetidos em nenhum first(A), portanto, esta condição é cumprida.

1.2.2: α → ε ou β → ε, mas não ambos
Esta condição também é cumprida pelo mesmo motivo da condição 1.2.1. Cada .. somente tem epsilon 1x

1.2.3 se α ⇒* ε ou β ⇒* ε, então first(A) ∩ follow(A) = φ

Computamos os conjuntos follow para os terminais onde ε ∈ first(A), isto é, A ⇒* ε:







1) FOLLOW(S) = { $ }   // where S is the starting Non-Terminal

2) If A -> pBq is a production, where p, B and q are any grammar symbols,
   then everything in FIRST(q)  except ? is in FOLLOW(B.

3) If A->pB is a production, then everything in FOLLOW(A) is in FOLLOW(B).

4) If A->pBq is a production and FIRST(q) contains ?, 
   then FOLLOW(B) contains { FIRST(q) – ? } U FOLLOW(A) 









follow(cols) 	= first(vardecl1) ∪ first(IDENT) ∪ first(paramlist1) ∪ first(virgidentcols)
			 	=  {VIRG} ∪ follow(vardecl) ∪ follow(vardecl1) ∪ {IDENT} ∪ {VIRG} ∪ follow(paramlist) ∪ follow(paramlist1) ∪ {VIRG} ∪ {PTVIR} ∪ follow(virgidentcols)









follow(vardecl1) = 
follow(paramlist) =  
follow(paramlist1) = 
follow(virgidentcols) = 
follow(statement2) = 
follow(ifstat1) = 
follow(lvalue2) = 
follow(lvalue3) = 
follow(alocexpression4) = 
follow(expresion3) = 
follow(numexpression1) = 
follow(term1) = 
follow(arglist1) = 
follow(classbody1) = 
follow(classbody2) = 
follow(classbody3) = 
follow(statement4) = 
follow(forstat1) = 
follow(statlist1) = 
follow(classlist2) = 
follow(program) = 
follow(arglist) = 
follow(returnstat1) = 





















first(A, B) : A->B



follow(program) = {EOF}
follow(classlist) = follow(program), follow(classlist2), first(classbody1 classbody2 classbody3 FECHCHAVE)
follow(classdecl) = first(classlist2, epsilon=follow(classlist)),
follow(classlist2) = follow(classlist)
follow(classdecl2) = follow(classdecl) 
follow(classbody) = {EXTENDS}, follow(classbody)
follow(classbody1) = first(classbody2 classbody3 FECHCHAVE)
follow(classbody2) = first(classbody3 FECHCHAVE)
folllow(classbody3) = {FECHCHAVE}
follow(vardecl) = {PTVIR}
follow(constructdecl) = first(classbody2; epsilon=follow(classbody2)
follow(methoddecl) = first(classbody3, epsilon=follow(classbody3))
follow(intstringident) = {IDENT}, first(cols IDENT methodbody)
follow(cols) = first(vardecl1, epsilon=follow(vardecl)), first(vardecl1, epsilon=follow(vardecl1)), {IDENT}
follow(vardecl1) = follow(vardecl1)
follow(methodbody) = follow(constructdecl), follow(methoddecl)
follow(paramlist) = {FECHPAR}
follow(statement) = follow(methodbody)






paramlist 		: intstringident IDENT cols paramlist1
				| /* epsilon */;

paramlist1 		: VIRG intstringident IDENT cols paramlist1
				| /* epsilon */;

statement 		: intstring IDENT cols virgidentcols PTVIR
				| IDENT statement2
				| printstat PTVIR
				| readstat PTVIR
				| returnstat PTVIR
				| ifstat
				| forstat
				| ABRCHAVE statlist FECHCHAVE
				| BREAK PTVIR
				| PTVIR;

intstring 		: INT
				| STRING;

virgidentcols 	: VIRG IDENT cols virgidentcols
				| /* epsilon */;

statement2 		: IDENT cols virgidentcols PTVIR
				| statement3 ATR expralocexpr PTVIR;

statement3		: ABRCOL expression FECHCOL statement3
				| PONTO IDENT ABRPAR arglist FECHPAR statement3
				| PONTO IDENT statement3
				| /* epsilon */;

expralocexpr	: expression
				| alocexpression;

atribstat 		: lvalue ATR expralocexpr;
printstat 		: PRINT expression;
readstat 		: READ lvalue;

returnstat 		: RETURN returnstat1; 

returnstat1 	: expression
				| /* epsilon */;

superstat 		: SUPER ABRPAR arglist FECHPAR;

ifstat 			: IF ABRPAR expression FECHPAR THEN statement ifstat1;
				
ifstat1			: ELSE statement 
				| /* epsilon */;

forstat 		: FOR ABRPAR forstat1 PTVIR forstat2;

forstat1 		: atribstat
				| /* epsilon */;

forstat2 		: PTVIR forstat1 FECHPAR statement 
				| expression PTVIR forstat1 FECHPAR statement;

statlist 		: statement statlist1;

statlist1 		: statlist 
				| /* epsilon */;


lvalue 			: IDENT lvalue2;

lvalue2 		: ABRCOL expression FECHCOL
				| PONTO IDENT lvalue3
				| /* epsilon */;

lvalue3 		:  ABRPAR arglist FECHPAR lvalue2 
				| /* epsilon */;

alocexpression 	: NEW alocexpression3;

alocexpression2 : ABRCOL expression FECHCOL alocexpression4;

alocexpression3 : IDENT alocexpression5 
				| INT alocexpression2 
				| STRING alocexpression2;

alocexpression4 : alocexpression2 
				| /* epsilon */;

alocexpression5: ABRPAR arglist FECHPAR |alocexpression2;

expression 		: numexpression expresion3;

expression2 	: MENOR
				| MAIOR
				| MENORIG
				| MAIORIG
				| IGUAL
				| DIFER;

expresion3 		: expression2 numexpression | /* epsilon */;

numexpression 	: term numexpression2;

numexpression2 	: OPMAIS term numexpression2
				| OPMENOS term numexpression2
				| /* epsilon */;

term 			: unaryexpr term1;

term1 			: OPVEZES unaryexpr term1
				| OPDIV unaryexpr term1
				| OPMOD unaryexpr term1
				| /* epsilon */;

unaryexpr 		: OPMAIS factor
				| OPMENOS factor
				| factor;

factor 			: INTCONSTANT
				| STRINGCONSTANT
				| NULL
				| lvalue
				| ABRPAR expression FECHPAR;

arglist 		: expression arglist1
				| /* epsilon */;

arglist1 		: VIRG expression arglist1
				| /* epsilon */;
























Sendo EOF o símbolo que indica o final do programa.

Agora, verificamos as condições 1.2.1, 1.2.2 e 1.2.3 para todas as produções da gramática:

1.2.1: first(α) ∩ first(β) = φ:



pode testar com a tabela, desde que seja livre rec À esquerda e fatorada à esquerda


 
1.3. construa um analisador sintático para LL1X++:

